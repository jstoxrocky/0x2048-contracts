pragma solidity ^0.6.0;


import "./SafeMath.sol";


/// @title Arcade
/// @author Joseph Stockermans (https://github.com/jstoxrocky)
/// @dev Payment logic for 0x2048 blockchain-integrated game
contract Arcade {
    using SafeMath for uint256;
    address public owner;
    uint256 public jackpot;
    uint256 public highscore;
    uint256 public price;
    uint256 public round;
    mapping (address => bytes32) public nonces;

    constructor() public {
        // Set initial values
        // Initial price is set to 0.0001 ETH
        highscore = 0;
        jackpot = 0;
        round = 1;
        price = 100000000000000; // 0.0001 ETH
        owner = msg.sender;
    }

    /// @dev Submit payment for a round of gameplay
    /// @dev Associate the msg.sender with the submitted nonce value
    /// @dev Add the msg.value to the jackpot
    /// @param nonce The random nonce generated by the game server
    function pay(bytes32 nonce) public payable {
        require(msg.value == price, "Value not equal to price");
        nonces[msg.sender] = nonce;
        jackpot = jackpot.add(msg.value);
    }

    function getNonce(address addr) public view returns (bytes32) {
        return nonces[addr];
    }

    /// @dev Submit highscore
    /// @dev Do not accept scores that are not signed by 0x2048 game server
    /// @dev Do not accept scores less than or equal to the current highscore
    /// @dev Replace the highscore with the submitted score
    /// @dev Increase the round
    /// @dev Set jackpot to zero
    /// @dev Send previous jackpot to user address
    /// @param v Signature parameter
    /// @param r Signature parameter
    /// @param s Signature parameter
    /// @param score Pre-keccak256 score
    function uploadScore(
        uint8 v,
        bytes32 r,
        bytes32 s,
        uint256 score
    ) public {
        // The user uploads their score along with the signature
        // from the Arcade server. Since the user's address forms part
        // of the signature, it is necessary that the user who paid the
        // Arcade server be the one to transact to this method.

        // Although the signing account is owned by the Arcade, it is
        // necessary to follow the preventative measure against replay-attacks
        // outlined in EIPs 191 and 712. Preventing Ethereum transactions from
        // being signed (Geth PR 2940, EIP 191, EIP 712) is not necessarily a
        // concern here since the signing account controlled by the Arcade.
        // Likewise, EIP 712's strict guidelines for encoding an arbitrary
        // structured message to bytes is not necessarily a concern either
        // since the Arcade again controls the signing logic. However, since
        // the only downside to added these security measures is an increase
        // in gas to power the method, and the method is executed by the user,
        // it is easier to not "roll our own crypto" here and just use EIP 712's
        // guidelines for signing.

        // After the signer is verified to be the Arcade server the
        // score is checked to ensure that it is not greater than the
        // current highscore. If these checks pass, the highscore is
        // updated and the value of the jackpot is transferred to the message
        // sender.

        // EIP 191 Version 1 (EIP 712)
        //      domainTypeHash = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');
        bytes32 domainTypeHash = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;
        //      name = keccak256('0x2048')
        bytes32 name = 0xa7fc84919e7612cb73ee05a72c871940b9845869baf1a644b713770b676b2525;
        //      version = keccak256('1.0')
        bytes32 version = 0xe6bbd6277e1bf288eed5e8d1780f9a50b239e86b153736bceebccf4ea79d90b3;
        uint256 chainId = 1;
        address validator = address(this);
        bytes32 domainSeparator = keccak256(
            abi.encode(domainTypeHash, name, version, chainId, validator)
        );
        //      highscoreTypeHash = keccak256('Highscore(address user,uint256 score)');
        bytes32 highscoreTypeHash = 0x49d8d27ca6ea49c11b929c6f196a934d26e531707cc4be78256fee34a5ba8889;
        bytes32 hashStruct = keccak256(
            abi.encode(highscoreTypeHash, msg.sender, score)
        );
        bytes32 messageHash = keccak256(abi.encodePacked(byte(0x19), byte(0x01), domainSeparator, hashStruct));
        address signer = ecrecover(messageHash, v, r, s);
        require(signer == owner, "Signer not Arcade");

        // User must have scored higher than highscore.
        // This must be greater-than to prevent replay attacks.
        require(score > highscore, "Score not greater than Highscore");
        // Send jackpot to address included in hashed-signed message
        // Reset jackpot
        highscore = score;
        round = round.add(1);
        uint256 currentJackpot = jackpot;
        jackpot = 0;
        msg.sender.transfer(currentJackpot);
    }
}
