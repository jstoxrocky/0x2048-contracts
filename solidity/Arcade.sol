pragma solidity ^0.4.18;


import "./SafeMath.sol";


/// @title Arcade
/// @author Joseph Stockermans (https://github.com/jstoxrocky)
/// @dev Payment logic for 0x2048 blockchain-integrated game
contract Arcade {
    using SafeMath for uint256;
    address public owner;
    uint256 public jackpot;
    uint256 public highscore;
    uint256 public price;
    uint256 public round;
    mapping (address => bytes32) public nonces;

    function Arcade() public {
        // Set initial values
        // Initial price is set to 0.0001 ETH
        highscore = 0;
        jackpot = 0;
        round = 1;
        price = 100000000000000; // 0.0001 ETH
        owner = msg.sender;
    }

    /// @dev Submit payment for a round of gameplay
    /// @dev Associate the msg.sender with the submitted nonce value
    /// @dev Add the msg.value to the jackpot
    /// @param nonce The random nonce generated by the game server
    function pay(bytes32 nonce) public payable {
        require(msg.value == price);
        nonces[msg.sender] = nonce;
        jackpot = jackpot.add(msg.value);
    }

    function getNonce(address addr) public view returns (bytes32) {
        return nonces[addr];
    }

    /// @dev Submit highscore
    /// @dev Do not accept scores that are not signe dby 0x2048 game server
    /// @dev Do not accept scores less than or equal to the current highscore
    /// @dev Replace the highscore with the submitted score
    /// @dev Increase the round
    /// @dev Set jackpot to zero
    /// @dev Send previous jackpot to user address
    /// @param v Signature parameter
    /// @param r Signature parameter
    /// @param s Signature parameter
    /// @param user Preimage user address
    /// @param score Preimage score
    function uploadScore(
        uint8 v, 
        bytes32 r, 
        bytes32 s, 
        address user, 
        uint256 score
    ) public {
        // Verify signer
        bytes memory preamble = "\x19Ethereum Signed Message:\n32";
        bytes32 messageHash = keccak256(preamble, keccak256(this, user, score));
        address signer = ecrecover(messageHash, v, r, s);
        require(signer == owner);
        // User must have gotten higher than highscore
        require(score > highscore);
        // Send jackpot to address included in hashed-signed message
        // Reset jackpot
        highscore = score;
        round = round.add(1);
        uint256 currentJackpot = jackpot;
        jackpot = 0;
        user.transfer(currentJackpot);
    }
}