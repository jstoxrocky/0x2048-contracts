pragma solidity ^0.6.0;


import "./SafeMath.sol";


/// @title Arcade
/// @author Joseph Stockermans (https://github.com/jstoxrocky)
/// @dev Payment logic for 0x2048 blockchain-integrated game
contract Arcade {
    using SafeMath for uint256;
    address public owner;
    uint256 public jackpot;
    uint256 public highscore;
    uint256 public price;
    uint256 public round;
    mapping (address => bytes32) public nonces;

    constructor() public {
        // Set initial values
        // Initial price is set to 0.0001 ETH
        highscore = 0;
        jackpot = 0;
        round = 1;
        price = 100000000000000; // 0.0001 ETH
        owner = msg.sender;
    }

    /// @dev Submit payment for a round of gameplay
    /// @dev Associate the msg.sender with the submitted nonce value
    /// @dev Add the msg.value to the jackpot
    /// @param nonce The random nonce generated by the game server
    function pay(bytes32 nonce) public payable {
        require(msg.value == price, "Value not equal to price");
        nonces[msg.sender] = nonce;
        jackpot = jackpot.add(msg.value);
    }

    function getNonce(address addr) public view returns (bytes32) {
        return nonces[addr];
    }

    /// @dev Submit highscore
    /// @dev Do not accept scores that are not signed by 0x2048 game server
    /// @dev Do not accept scores less than or equal to the current highscore
    /// @dev Replace the highscore with the submitted score
    /// @dev Increase the round
    /// @dev Set jackpot to zero
    /// @dev Send previous jackpot to user address
    /// @param v Signature parameter
    /// @param r Signature parameter
    /// @param s Signature parameter
    /// @param user Pre-keccak256 user address
    /// @param score Pre-keccak256 score
    function uploadScore(
        uint8 v,
        bytes32 r,
        bytes32 s,
        address payable user,
        uint256 score
    ) public {
        // The user uploads their score and own address to verify that these are
        // the values that the contract will actually use (and also to provide the code
        // access to these values after signature verification).
        // The user also uploads the v/r/s signature given by the Arcade server.
        // This v/r/s signature is expected to be the hashed and signed combination of
        // the contract's address, user's address, and score. The signer is the Arcade server.
        // The code below, rehashes these values together, uses the v/r/s signature in combination
        // with this hash to verify that the signature does indeed come from the Arcade server.
        // Next, the score is checked to ensure that it is not greater
        // than the current highscore.
        // If these checks pass, the highscore is updated and the value of the jackpot is
        // transferred to the user.

        // Verify signer
        // `this` (the contract's address) is included here less as an immediate
        // security measure and more as a future proofing premptive security measure. If, in
        // the future, there is another Arcade contract (maybe a revised version etc.), user's
        // could upload scores to multiple versions of the contract - potentially claiming
        // the jackpot from a contract they weren't intended to access. Including `this` in the
        // signed message requires submissions to be intended to be used with this exact contract.
        bytes32 messageHash = keccak256(abi.encodePacked(this, user, score));
        address signer = ecrecover(messageHash, v, r, s);
        require(signer == owner, "Signer not Arcade");

        // User must have scored higher than highscore
        require(score > highscore, "Score not greater than Highscore");
        // Send jackpot to address included in hashed-signed message
        // Reset jackpot
        highscore = score;
        round = round.add(1);
        uint256 currentJackpot = jackpot;
        jackpot = 0;
        user.transfer(currentJackpot);
    }
}